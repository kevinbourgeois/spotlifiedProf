{"mappings":"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","sources":["src/api.js","src/sections/artists.js","src/lib/formatTimestamp.js","src/sections/player.js","src/sections/songs.js","src/sections/search_input.js","src/index.js"],"sourcesContent":["// URL de base du serveur\nconst BASE_URL = 'https://webmob-ui-22-spotlified.herokuapp.com'\n\n// Fonction loadJson utilisée à l'interne. Elle s'occupe de charger l'url passée en paramètre et convertir\n// son résultat en json\nconst loadJson = (url) => {\n  return fetch(url)\n    .then((response) => response.json())\n}\n\n// Retourne une liste d'artistes\nconst getArtists = () => {\n  return loadJson(`${BASE_URL}/api/artists`)\n}\n\n// Retourne la liste des chansons d'un ariste\nconst getSongsForArtist = (id) => {\n  return loadJson(`${BASE_URL}/api/artists/${id}/songs`)\n}\n\n// Retourne un résultat de recherche\nconst searchSongs = (query) => {\n  return loadJson(`${BASE_URL}/api/songs/search/${encodeURIComponent(query)}`)\n}\n\nexport { getArtists, getSongsForArtist, searchSongs }\n","import { getArtists } from '../api'\n\n // On obtient l'élément DOM qui nous servira de template pour un élément de la liste d'artistes\nconst artistListItemTemplate = document.querySelector('#artist-list-item-template')\n\n// Element DOM de la liste à manipuler\nconst artistList =  document.querySelector('.artist-list')\n\n// Génère le HTML nécessaire pour afficher la liste des artistes\nconst renderArtists = () => {\n  // On vide la liste de ses anciennes informations, pour en ajouter de nouvelles à jour\n  artistList.replaceChildren()\n\n  // On récupère les artistes depuis l'API\n  getArtists()\n    .then((artists) => {\n      // On itère sur chacun des artistes récupérés depuis l'API\n      artists.forEach((artist) => {\n        // Créer une copie du template et de son contenu pour avoir un nouvelle élément vierge\n        // que l'on stock dans la variable newArtistItem\n        const newArtistItem = artistListItemTemplate.content.cloneNode(true)\n\n        // On modifie l'url du lien qui se trouve à l'intérieur, pour avoir une URL du style #artists-12\n        newArtistItem.querySelector('a').href = '#artists-' + artist.id\n\n        // On rempli le titre de l'artiste dans ce nouvel élément, en sélectionnant l'élément\n        // artist-list-item-title à l'intérieur (!dans newArtistItem! Pas dans document)\n        newArtistItem.querySelector('.artist-list-item-title').innerHTML = artist.name\n\n        // On modifie le src de l'image qui se trouve à l'intérieur, pour afficher la cover de l'artiste\n        newArtistItem.querySelector('img').src = artist.image_url\n\n        // On l'ajoute à la liste d'artistes\n        artistList.append(newArtistItem)\n      })\n    })\n}\n\nexport default renderArtists\n","export default function formatTimestamp(timestamp) {\n  timestamp = parseInt(timestamp, 10)\n  let hours   = Math.floor(timestamp / 3600)\n  let minutes = Math.floor((timestamp - (hours * 3600)) / 60)\n  let seconds = timestamp - (hours * 3600) - (minutes * 60)\n\n  if (minutes < 10) minutes = \"0\" + minutes\n  if (seconds < 10) seconds = \"0\" + seconds\n  return minutes + ':' + seconds\n}\n","import formatTimestamp from '../lib/formatTimestamp'\n\nclass Player {\n  ////////// Constantes des différents tags HTML\n  // Tag audio\n  #audioPlayer = document.querySelector('#audio-player')\n\n  // Song infos\n  #playerThumbnail = document.querySelector('#player-thumbnail-image')\n  #playerSongTitle = document.querySelector('#player-infos-song-title')\n  #playerArtistName = document.querySelector('#player-infos-artist-name')\n\n  // Controls\n  #playerPrev = document.querySelector('#player-control-previous')\n  #playerPlay = document.querySelector('#player-control-play')\n  #playerPlayIcon = document.querySelector('#player-control-play .material-icons')\n  #playerNext = document.querySelector('#player-control-next')\n\n  // Progress\n  #playerTimeCurrent = document.querySelector('#player-time-current')\n  #playerTimeDuration = document.querySelector('#player-time-duration')\n  #playerProgress = document.querySelector('#player-progress-bar')\n\n  // Logo\n  #logo = document.querySelector('#logo')\n\n  ////////// Logique\n\n  // songs contiendra la liste des chansons en cours de lecture, afin de pouvoir se déplacer entre les chansons\n  songList = []\n  // La chanson en cours de lecture\n  currentSong = null\n\n  constructor() {\n    // On écoute le clique sur le bouton play et on transmets l'instruction au player\n    this.#playerPlay.addEventListener('click', () => {\n      if(this.#audioPlayer.paused)\n        this.#audioPlayer.play()\n      else\n        this.#audioPlayer.pause()\n    })\n\n    // Bouton précédent. Attention à transmettre proprement la méthode, via une fonction fléchée, autrement le \"this\"\n    // résolvera à l'event et non au \"this\" de l'instance actuelle de la classe\n    this.#playerPrev.addEventListener('click', () => this.playPreviousSong())\n\n    // Bouton suivant. Attention à transmettre proprement la méthode, via une fonction fléchée, autrement le \"this\"\n    // résolvera à l'event et non au \"this\" de l'instance actuelle de la classe\n    this.#playerNext.addEventListener('click', () => this.playNextSong())\n\n    // Lorsque l'on click sur la barre de progression, on change sa valeur et elle émet donc un événement \"change\" pour\n    // avertir de son changement. Comme on a défini la valeur max comme étant la durée totale de la chanson, toute valeur\n    // transmise est forcément incluse dans cet interval. On peut alors la passer au player sans problème\n    this.#playerProgress.addEventListener('change', (event) => {\n      this.#audioPlayer.currentTime = event.currentTarget.value\n    })\n\n    // Lorsque nous faison \".src = \" sur le player, celui-ci va télécharger la chanson en arrière plan et calculer\n    // sa longueur. Lorsque c'est fait, il émet un event \"durationchange\" pour nous informer qu'il connait maintenant\n    // sa durée (en secondes!) et que l'on peut se servir de cette information\n    this.#audioPlayer.addEventListener('durationchange', () => {\n      // On défini la valeur maximum du slider de la chanson comme étant sa durée en secondes\n      this.#playerProgress.max = this.#audioPlayer.duration\n      // On affiche la durée totale, grâce à la fonction de formattage du temps\n      this.#playerTimeDuration.innerText = formatTimestamp(this.#audioPlayer.duration)\n    })\n\n    // Lorsque la chanson est en cours de lecture, l'événement \"timeupdate\" sera envoyé plusieurs fois par seconde\n    // pour avertir de l'avancée dans la lecture. C'est cet événement qui nous permet de bouger la barre de progression\n    // au fur et à mesure que la chanson se lit.\n    this.#audioPlayer.addEventListener('timeupdate', () => {\n      // On récupère la valeur \"currentTime\" qui est la position dans la chanson au sein du player et on la transmets\n      // à la progress bar comme étant sa valeur. La progress bar a comme valeur minimum 0 et comme valeur max la durée\n      // totale de la chanson. En lui passant le currrentTime, il sera forcément entre le min et le max et le browser\n      // pourra afficher la petite boule au bon endroit\n      this.#playerProgress.value = this.#audioPlayer.currentTime\n      // On affiche la position de lecture, grâce à la fonction de formattage du temps\n      this.#playerTimeCurrent.innerText = formatTimestamp(this.#audioPlayer.currentTime)\n    })\n\n    // Lorsque le player se met en lecture, il émet un évent \"play\" pour annoncer le début de lecture. Dans ce cas,\n    // on change l'icône du bouton play à pause\n    //\n    // Pourquoi faire ça ici et non dans le \"click\" sur le bouton ? :) Que se passe-t-il si vous utilisez le bouton\n    // \"play/pause\" natif qui se trouve sur votre clavier ? Cela va mettre en pause la chanson, mais l'événement \"click\"\n    // du bouton play/pause ne sera pas émis, donc icône pas mis à jour, car vous avez utilisez votre clavier et\n    // non le bouton.\n    // En revanche, lorsque votre OS reçoit le click sur le clavier, il trouve l'application qui émet du son (en l'occ.\n    // notre browser) et lui demande d'arrêter. Le browser va chercher quel élément audio lis actuellement de la musique\n    // et va faire un \"audioPlayer.pause()\". Les évenements play/pause seront donc transmis et c'est pour cela qu'il est\n    // mieux de gérer le changement d'icône ici\n    this.#audioPlayer.addEventListener('play', () => this.#updateIcon())\n\n    // Lorsque le player pause la lecture, il émet un évent \"pause\" pour annoncer le pause de lecture. Dans ce cas,\n    // on change l'icône du bouton pause à play\n    // voir commentaire précédent\n    this.#audioPlayer.addEventListener('pause', () => this.#updateIcon())\n  }\n\n  // Lire une chanson sur laquelle on clique\n  playSong(song, songs) {\n    // On enregistre la chanson en cours de lecture\n    this.currentSong = song\n\n    // si un tableau est transmis, on le met à jour. Cela nous permet d'utiliser juste playSong(song) à l'interne,\n    // sans devoir le repasser à chaque fois (depuis previous/next, par exemple)\n    if(songs)\n      this.songList = songs\n\n    // On donne l'url au player et démarre la lecture\n    this.#audioPlayer.src = song.audio_url\n    this.#audioPlayer.play()\n\n    // Remplacement des différentes informations au sein des tags\n    this.#playerSongTitle.innerHTML = song.title\n    this.#playerArtistName.innerHTML = song.artist.name\n    this.#playerThumbnail.src = song.artist.image_url\n  }\n\n  // Lis la chanson suivante, d'après la chanson en cours\n  playNextSong() {\n    const index = this.songList.indexOf(this.currentSong)\n    const newIndex = index + 1\n    // On s'assure qu'on n'arrive jamais en dehors du tableau et on reboucle sur le début\n    if(newIndex < this.songList.length)\n      this.playSong(this.songList[newIndex])\n    else\n      this.playSong(this.songList[0])\n  }\n\n  // Lis la chanson précédente, d'après la chanson en cours\n  playPreviousSong() {\n    const index = this.songList.indexOf(this.currentSong)\n    const newIndex = index - 1\n    // On s'assure qu'on n'arrive jamais en dehors du tableau et on reboucle sur la fin\n    if(newIndex >= 0)\n      this.playSong(this.songList[newIndex])\n    else\n      this.playSong(this.songList[this.songList.length - 1])\n  }\n\n  #updateIcon() {\n    if(this.#audioPlayer.paused) {\n      this.#playerPlayIcon.innerHTML = 'play_arrow'\n\n      // On arrête d'animer le logo de l'application lorsqu'aucune chanson ne se lit, pour moins de fancyness\n      this.#logo.classList.remove('animated')\n\n    } else {\n      this.#playerPlayIcon.innerHTML = 'pause'\n\n      // On anime le logo de l'application lorsqu'une chanson se lit, pour plus de fancyness\n      this.#logo.classList.add('animated')\n    }\n  }\n}\n\nconst playerSingleton = new Player()\n\nexport default playerSingleton\n","import { getSongsForArtist, searchSongs } from '../api'\nimport player from './player'\n\n// On obtient l'élément DOM qui nous servira de template pour un élément de la list\nconst songListItemTemplate = document.querySelector('#list-item-template')\n\n// Element DOM de la liste à manipuler\nconst songList = document.querySelector('.list')\n\n// Génère le HTML nécessaire pour afficher une liste de chansons, basé sur le tableau passé en paramètre\nconst renderSongs = (songs) => {\n  // On vide la liste de ses anciennes informations, pour en ajouter de nouvelles à jour\n  songList.replaceChildren()\n\n  // On itère sur chacune des chansons récupérées depuis l'API pour cet artiste\n  songs.forEach((song) => {\n    // Créer une copie du template et de son contenu pour avoir un nouvelle élément vierge\n    // que l'on stock dans la variable newSongItem\n    const newSongItem = songListItemTemplate.content.cloneNode(true)\n\n    // On rempli le titre de la chanson dans ce nouvel élément, en sélectionnant l'élément\n    // list-item-title à l'intérieur (!dans newSongItem! Pas dans document)\n    newSongItem.querySelector('.list-item-title').innerHTML = song.title\n\n    // Au clique sur le bouton play, on transmet la chanson et le tableau duquel elle provient au player. Cela permet de\n    // lire la chanson et passer le contexte actuel au player (le tableau) pour faire précédent/suivant\n    newSongItem.querySelector('.play-button').addEventListener('click', () => {\n      player.playSong(song, songs)\n      window.location.hash = '#player'\n    })\n\n    // On l'ajoute à la liste de chansons\n    songList.append(newSongItem)\n  })\n}\n\n// Génère le HTML nécessaire pour afficher la liste de chanson d'un artiste, basé sur son id\nconst renderSongsForArtistSection = (artistId) => {\n  // On récupère les songs d'un artiste depuis l'API, en se servant de son Id passé en paramètre\n  getSongsForArtist(artistId)\n    .then((songs) => {\n      // Set le nom de l'artiste\n      document.querySelector('#list-section h4').textContent = `Artistes > ${songs[0].artist.name}`\n\n      // Affiche les chansons\n      renderSongs(songs)\n    })\n}\n\n// Génère le HTML nécessaire pour afficher la liste de chanson d'un artiste, basé sur son id\nconst renderSongsForSearchSection = (query) => {\n  // On récupère les songs correspondant à la recherche depuis l'API, en se servant de la query passée en paramètre\n  searchSongs(query)\n    .then((songs) => {\n      // Set le nom de l'artiste\n      document.querySelector('#list-section h4').textContent = `Résultats pour \"${query}\"`\n\n      // Affiche les chansons\n      renderSongs(songs)\n    })\n}\n\nexport { renderSongsForArtistSection, renderSongsForSearchSection }\n","// Il n'y a en fait pas de section recherche à proprement parler. Ce fichier sert juste à ajouter des listeners sur\n// le champ de recherche, premièrement pour l'afficher/le cacher, puis pour rediriger vers l'url de recherche, avec\n// la query. C'est le display section qui va gérer la logique du listing\n\n// Tags pour la recherche\nconst searchTrigger = document.querySelector('#search-trigger')\nconst searchInput = document.querySelector('#search-input')\n\n// Quand on click sur la loupe, on affiche le champ de recherche et on focus l'input\nsearchTrigger.addEventListener('click', () => {\n  searchInput.classList.add('active')\n  searchInput.focus()\n})\n\n// Lorsque l'utilisateur sort du champ de recherche, on le cache et on le vide\nsearchInput.addEventListener('blur', () => {\n  searchInput.classList.remove('active')\n  searchInput.value = ''\n})\n\n// Lorsque l'utilisateur entre quelque chose dans le champ, on redirige vers l'url #search-:query, où query est\n// la valeur du camp encodée. On encode la chaine de recherche pour éviter les caractères spéciaux\n// (typiquement, un '-' qui embêterait notre fonction displaySection)\nsearchInput.addEventListener('change', () => {\n  window.location.hash = `#search-${encodeURIComponent(searchInput.value)}`\n})\n","import renderArtists from './sections/artists'\nimport { renderSongsForArtistSection, renderSongsForSearchSection } from './sections/songs'\n\n// On les importe au moins une fois dans l'index, pour être sûr que les eventlisteners seront appelés\nimport './sections/search_input'\n\n// S'occuper de \"toggler\" les liens dans la navigation\n// Désactiver le lien actif et activer le nouveau en bleu, selon l'url passée en paramètre de la fonction\nconst toggleNav = (hash) => {\n  // On va chercher le lien actuellement affiché (n'importe quel lien dans \"nav\" qui a une classe active) et en enlève\n  // la classe active\n  // NB: Noter le ? après le querySelector. Cela veut dire \"si on a trouvé quelque chose, on fait la suite, autrement rien\"\n  document.querySelector(`nav a.active`)?.classList.remove('active')\n  // On va chercher le lien avec pour url le href passé en argument et y ajouter la classe active pour le rendre bleu\n  // Exemple: <a href=\"#player\">...</a>\n  // NB: Noter le ? après le querySelector. Cela veut dire \"si on a trouvé quelque chose, on fait la suite, autrement rien\"\n  document.querySelector(`nav a[href=\"${hash}\"]`)?.classList.add('active')\n}\n\n// S'occuper de \"toggler\" les sections dans le body, en cachant la section actuellement affichée, puis en ajoutant\n// la classe active à la nouvelle pour l'afficher\nconst toggleSection = (hash) => {\n  // Comme pour le menu, on enlève la classe active à la section en cours\n  document.querySelector(`section.active`)?.classList.remove('active')\n  // et on essaie de trouver la section correspondante et l'afficher, en y ajoutant la classe active\n  document.querySelector(`${hash}-section`)?.classList.add('active')\n}\n\nconst displaySection = (hash) => {\n  if(hash == '') hash = '#home'\n\n  const hashSplit = hash.split('-')\n\n  // On appelle la fonction toggleNav qui va s'occuper de \"toggler\" les liens dans la navigation. On se sert toujours\n  // de la première partie de l'url (comme ça, si #artists-12 --> #artists est sélectionné)\n  toggleNav(hashSplit[0])\n\n  // On appelle la fonction toggleSection qui va s'occuper de \"toggler\" les sections dans le body. Par défaut, la première\n  // partie de l'url correspond à une section dans le HTML, par exemple -> #home --> #home-section. Dans certains cas,\n  // on va appeler cette fonction manuellement avec une valeur spécifique, pour afficher la section list, car l'url\n  // ne correspond pas\n  toggleSection(hashSplit[0])\n\n  switch(hashSplit[0]) {\n    case '#artists':\n      // S'il y a un paramètre derrière...? Ex: -> #artists-12 -> hashSplit[1] vaudra 12\n      if(hashSplit[1]){\n        // Cela nous permet d'afficher la section générique \"list\"\n        toggleSection('#list')\n        renderSongsForArtistSection(hashSplit[1])\n      }\n      else {\n        renderArtists()\n      }\n    break;\n\n    case '#search':\n      toggleSection('#list')\n      renderSongsForSearchSection(hashSplit[1])\n      break;\n\n    case '#favorites':\n      toggleSection('#list')\n    break;\n  }\n}\n\n// On link la fonction \"displaySection\" à l'événement hashchange pour être averti d'un changement de hash dans l'url\nwindow.addEventListener('hashchange', () => displaySection(window.location.hash))\n\n// Affichage au chargement pour traiter l'url en cours (exemple: on ouvre un lien dans un nouvel onglet)\ndisplaySection(window.location.hash)\n"],"names":["$96e14f2a7c3555e4$var$BASE_URL","$96e14f2a7c3555e4$var$loadJson","url","fetch","then","response","json","$96e14f2a7c3555e4$export$fd49fd7de453819a","query","encodeURIComponent","$e56b8ad525cbc6a1$var$artistListItemTemplate","document","querySelector","$e56b8ad525cbc6a1$var$artistList","$e56b8ad525cbc6a1$export$2e2bcd8739ae039","replaceChildren","artists","forEach","artist","newArtistItem","content","cloneNode","href","id","innerHTML","name","src","image_url","append","$fb06cff0c0b5c1ad$export$2e2bcd8739ae039","timestamp","parseInt","hours","Math","floor","minutes","seconds","$d2a9a06f1479efe2$export$2e2bcd8739ae039","audioPlayer","playerThumbnail","playerSongTitle","playerArtistName","playerPrev","playerPlay","playerPlayIcon","playerNext","playerTimeCurrent","playerTimeDuration","playerProgress","logo","songList","currentSong","constructor","this","addEventListener","paused","play","pause","playPreviousSong","playNextSong","event","currentTime","currentTarget","value","max","duration","innerText","updateIcon","playSong","song","songs","audio_url","title","newIndex","indexOf","length","classList","remove","add","$094e799a8fecf310$var$songListItemTemplate","$094e799a8fecf310$var$songList","$094e799a8fecf310$var$renderSongs","newSongItem","window","location","hash","$094e799a8fecf310$export$3b152bd728e163e7","artistId","textContent","$094e799a8fecf310$export$8c266e98d86d2877","$f9b1f4c260254a3e$var$searchTrigger","$f9b1f4c260254a3e$var$searchInput","focus","$35da740d59af89ba$var$toggleSection","$35da740d59af89ba$var$displaySection","hashSplit","split","$35da740d59af89ba$var$toggleNav"],"version":3,"file":"index.b97bb1b9.js.map"}